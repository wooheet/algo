import re


def solution(s):
    answer = []
    s = s[2:-2]
    s = s.split("},{")
    print(s)
    s.sort(key = len)
    print(s)

    for i in s:
        ii = i.split(',')
        for j in ii:
            if int(j) not in answer:
                answer.append(int(j))
    print(answer)
    return answer

# s = "{{2},{2,1},{2,1,3},{2,1,3,4}}"  # [2, 1, 3, 4]
s = "{{1,2,3},{2,1},{1,2,4,3},{2}}" # [2, 1, 3, 4]
# s = "{{4,2,3},{3},{2,3,4,1},{2,3}}" #  {{3},{3,2},{3,2,4},{3,2,4,1}} , [3, 2, 4, 1]
solution(s)


# Q. 튜플
# -> 어떤식으로 풀었는지 설명
# String으로 받는 s를 숫자 형태로 구분하기 위해 문자열을 잘라준다.
# s[2:-2]를 하게되면 결과는 "{{2},{2,1},{2,1,3},{2,1,3,4}}" 값에서 --> "2},{2,1},{2,1,3},{2,1,3,4" 이런식으로 스트링이 변환된다.
# 그런 다음, '},{' 기준을 split을 하게되면, 콤마로 구분되는 숫자 형태로만 리스트로 남게 된다.
# 문자열은 ['2', '2,1', '1,2,3', '1,2,4,3'] 이런식으로 콤바로 구분된 원소들로 구분된다.
#           ['2','1']
# 그리고 len기준으로 sort를 해준다.
# 반복문에 들어오는 원소마다 ',' 콤마로 나누어 다시 배열로 만들어준다.
# answer에 배열에 차례대로 넣어준다.
#
#
# -> 사용한 자료구조를 왜 사용하였는지
# String으로 된 하나의 문자열을 숫자로 구분하기 위해 split함수를 사용하였다.
# 튜플의 순서를 정렬하기 위해 튜플의 길이마다 정렬 함수를 사용하였다.
#
# -> 시간 복잡도는?
# 시간 복잡도는 O(N^2) + O(NlogN) -> O(NlogN)의 시간복잡도가 나온다.
#
# -> 개선해야할 점이 무엇인지
# 스플릿 함수로 숫자를 구분하지 않고, regex로 숫자를 구분하여보자